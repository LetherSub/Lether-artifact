

# This file was *autogenerated* from the file mmPKE-gen.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_1p0 = RealNumber('1.0'); _sage_const_0 = Integer(0); _sage_const_0p5 = RealNumber('0.5'); _sage_const_32 = Integer(32); _sage_const_70368744177829 = Integer(70368744177829); _sage_const_64 = Integer(64); _sage_const_26 = Integer(26); _sage_const_16 = Integer(16); _sage_const_61 = Integer(61); _sage_const_6p36 = RealNumber('6.36'); _sage_const_12191p83 = RealNumber('12191.83'); _sage_const_30 = Integer(30); _sage_const_887 = Integer(887); _sage_const_4 = Integer(4); _sage_const_2p0 = RealNumber('2.0'); _sage_const_8 = Integer(8)
import re
import random
#from sage.stats.distributions.discrete_gaussian_integer import DiscreteGaussianSampler

from random import gauss

from math import floor, ceil

from copy import deepcopy


# === 工具函数 ===
def to_poly_list(flat_list, num_polys, deg):
    return [Rq(flat_list[i * deg:(i + _sage_const_1 ) * deg]) for i in range(num_polys)]

def R2_to_poly_list(flat_list, num_polys, deg):
    return [Rq2(flat_list[i * deg:(i + _sage_const_1 ) * deg]) for i in range(num_polys)]

def centered_mod(c, q):
    return ((int(c) + q // _sage_const_2 ) % q) - q // _sage_const_2 

def centered_poly(poly, q):
    return [centered_mod(c, q) for c in poly.list()]

def discrete_gaussian_sample(sigma=_sage_const_1p0 ):
    return int(round(gauss(_sage_const_0 , sigma)))

def round_away(x):
    return int(x + _sage_const_0p5 ) if x >= _sage_const_0  else int(x - _sage_const_0p5 )


def int_to_bin_list(x, bit_len=None):
    if x < _sage_const_0 :
        raise ValueError("error")
    bin_str = bin(x)[_sage_const_2 :]  # 去除 '0b' 前缀
    bin_list = [int(b) for b in bin_str[::-_sage_const_1 ]]  # 转换为列表并反转（低位在前）
    if bit_len is not None:
        while len(bin_list) < bit_len:
            bin_list.append(_sage_const_0 )
    return bin_list

def decrypt(c, ct ,sk):
    acc = Rq(_sage_const_0 )
    global m
    global d
    global eval_t
    for i in range(m):
        acc += c[i] * sk[i]
    mn = ct - acc
    mn_list = mn.list()
    m_list = []
    de_list = []
    sum_m = _sage_const_0 
    for i in range(d):
        m = (round_away(float(mn_list[i]) / float(q / (_sage_const_2  * eval_t + _sage_const_2 )))) % (_sage_const_2  * eval_t + _sage_const_2 )
        m_list.append(m)
        de = x - m * (_sage_const_2  * eval_t + _sage_const_2 )
        de_list.append(de)
    for i in range(_sage_const_32 ):
        sum_m += _sage_const_2 **i * (m_list[i] - eval_t)
    print(m_list)
    print(sum_m)


def decompose(elem, bound):
    length = ceil(log(bound, _sage_const_2 ))
    #bins = [0] * length
    beta = bound - _sage_const_2 **(length - _sage_const_1 )
    if elem >= beta:
        tmp = elem - beta
        flag = _sage_const_1 
    else: 
        tmp = elem
    #print("beta = ", beta)
    #print("tmp = ", tmp)
    bin_list = int_to_bin_list(tmp, length - _sage_const_1 )
    bin_list += [flag]
    return bin_list, beta, length


#print(decompose(60, 124))

#exit()

q = _sage_const_70368744177829 
global d
d = _sage_const_64   # 多项式次数
global m 
global n   # A 是 2x2 矩阵，s 和 e 向量长度为 2
m = _sage_const_26 
n = _sage_const_26 

num_rec = _sage_const_16 

sigma = _sage_const_1p0 
center = _sage_const_0 

global eval_t
eval_t = _sage_const_61 
#sampler = DiscreteGaussianSampler(sigma=sigma, center=center)


# === 多项式环定义 Rq = Z_q[x]/(x^d + 1) ===
R = PolynomialRing(Integers(q), names=('x',)); (x,) = R._first_ngens(1)
Rq = R.quotient(x**d + _sage_const_1 , 'xbar')
xbar = Rq.gen()

# === 输入：A 为一维列表（长度 = 2×2×4 = 16），允许使用负数（中心模表示） ===
A_list = [randint(-q//_sage_const_2 , q//_sage_const_2 ) for _ in range(d * m * n)]

B_list = [randint(-q//_sage_const_2 , q//_sage_const_2 ) for _ in range(d * num_rec * n)]

# s_list 长度 = 2×4×2 = 16，前半是 s，后半是 e
s_list = [discrete_gaussian_sample(sigma=_sage_const_6p36 ) for _ in range(d * (m + n))]
s2_list = [discrete_gaussian_sample(sigma=_sage_const_6p36 ) for _ in range(d * (m + n))]

y_list = [discrete_gaussian_sample(sigma=_sage_const_12191p83 ) for _ in range(d * num_rec)]
y2_list = [discrete_gaussian_sample(sigma=_sage_const_12191p83 ) for _ in range(d )]

c2_list = [randint(-q//_sage_const_2 , q//_sage_const_2 ) for _ in range(d * m * num_rec)]

ct2_list = [randint(-q//_sage_const_2 , q//_sage_const_2 ) for _ in range(d * num_rec)]

while(_sage_const_1 ):
    mo_list = [randint(_sage_const_0 , _sage_const_1 ) for _ in range(_sage_const_30 )] + [_sage_const_0 ]*(d-_sage_const_30 )
    mp_list = [randint(_sage_const_0 , _sage_const_1 ) for _ in range(_sage_const_30 )] + [_sage_const_0 ]*(d-_sage_const_30 )
    sum_mo = _sage_const_0 
    sum_mp = _sage_const_0 
    for i in range(_sage_const_32 ):
        sum_mo += _sage_const_2 **i * mo_list[i]
        sum_mp += _sage_const_2 **i * mp_list[i]
    if sum_mo >= sum_mp:
        mo_list = [x + eval_t for x in mo_list]
        break

print("old message:")
print(mo_list)
print(sum_mo)

print("update message:")
print(mp_list)
print(sum_mp)

index_s = randint(_sage_const_0 , num_rec - _sage_const_1 )

while(_sage_const_1 ):
    index_r = randint(_sage_const_0 , num_rec - _sage_const_1 )
    if index_r != index_s:
        break
    if num_rec == _sage_const_1 :
        break

sk_s_list = [randint(_sage_const_0 , _sage_const_1 ) for _ in range(d * m)]
sk_e_list = [randint(_sage_const_0 , _sage_const_1 ) for _ in range(d * n)]

IdR_list = [_sage_const_0 ] * (d * num_rec**_sage_const_2 )

# === 你预期的输出结果（中心模形式），每个为一个多项式的系数列表 ===
#templist = [
#    [-37, -9, 25, 65],     # 预期的 t[0]
#    [-84, -8, 74, 162]     # 预期的 t[1]
#]

# Set matrix A_H mod hat_q
set_random_seed(hash("Lether0"))
hat_p = _sage_const_887 
hat_q = hat_p * _sage_const_2 
n_pri = _sage_const_2 

AH_list = [randint(-_sage_const_1  * hat_q/_sage_const_2 , hat_q/_sage_const_2 -_sage_const_1 ) for _ in range(d * m * n_pri)]

S = PolynomialRing(Integers(hat_q), names=('x',)); (x,) = S._first_ngens(1)
Rq2 = S.quotient(x**d + _sage_const_1 , 'xbar2')
xbar2 = Rq2.gen()

AH_polys = R2_to_poly_list(AH_list, m * n_pri, d)
AH_poly = [[AH_polys[i * m + j] for j in range(m)] for i in range(n_pri)]
sh_poly = R2_to_poly_list(sk_s_list, m, d)[:m]

# Identity matrix with cmod
cmod = centered_mod(round_away(float (q) / float (_sage_const_2  * eval_t + _sage_const_2 )), q)
for i in range(num_rec):
    for j in range(num_rec):
        if i == j:
            IdR_list[(i * num_rec + j) * d] = cmod

# print("@@@@@@@", round_away(float (3329)/ float (2)))
# === 构造 A 矩阵 ===
A_polys = to_poly_list(A_list, m * n, d)
A_poly = [[A_polys[i * n + j] for j in range(n)] for i in range(m)]

# A's transfer matrix 
A_T_poly = [[A_poly[i][j] for i in range(m)] for j in range(n)]


# === 构造 B 矩阵 ===
B_polys = to_poly_list(B_list, num_rec * n, d)
B_poly = [[B_polys[i * n + j] for j in range(n)] for i in range(num_rec)]

c2_polys = to_poly_list(c2_list, num_rec * m, d)
c2_poly = [[c2_polys[i * m + j] for j in range(m)] for i in range(num_rec)]
ct2_poly = to_poly_list(ct2_list, num_rec, d)[_sage_const_0 :num_rec]

# === 构造向量 s 和 e ===
# num_vecs = n
# assert num_vecs == 4  # s + e 向量数为 2

s_poly = to_poly_list(s_list[:d * n], n, d)[:n]
s2_poly = to_poly_list(s2_list[:d * n], n, d)[:n]
e_poly = to_poly_list(s_list[d * n:], m, d)[:m]
e2_poly = to_poly_list(s2_list[d * n:], m, d)[:m]

y_poly = to_poly_list(y_list, num_rec, d)[:num_rec]
y2_poly = Rq(y2_list)

# m_poly = to_poly_list(m_list, 1, d)[0]

mp = Rq(mp_list)
mo = Rq(mo_list)

m_poly = [ ((i == index_r) - (i == index_s)) * mp  for i in range(num_rec)]

sk_s_poly = to_poly_list(sk_s_list, m, d)[:m]
sk_e_poly = to_poly_list(sk_e_list, n, d)[:n]

# === 执行计算 t = A * s + e ===
t_poly = []
for i in range(m):
    acc = Rq(_sage_const_0 )
    for j in range(n):
        acc += A_poly[i][j] * s_poly[j]
    acc += e_poly[i]
    t_poly.append(acc)

t2_poly = []
for i in range(m):
    acc = Rq(_sage_const_0 )
    for j in range(n):
        acc += A_poly[i][j] * s2_poly[j]
    acc += e2_poly[i]
    t2_poly.append(acc)


pk_poly = []
for i in range(n):
    acc = Rq(_sage_const_0 )
    for j in range(m):
        acc += A_T_poly[i][j] * sk_s_poly[j]
    acc += sk_e_poly[i]
    pk_poly.append(acc)

B_poly[index_s] = pk_poly

ct_poly = []
for i in range(num_rec):
    acc = Rq(_sage_const_0 )
    for j in range(n):
        acc += B_poly[i][j] * s_poly[j]
    acc += y_poly[i] + cmod * m_poly[i]
    ct_poly.append(acc)

for i in range(m):
    c2_poly[index_s][i] = t2_poly[i]

ct2 = Rq(_sage_const_0 )
i = index_s
for j in range(n):
    ct2 += B_poly[i][j] * s2_poly[j]
ct2 += y2_poly + cmod * mo

ct2_poly[index_s] = ct2


for i in range(num_rec):
    for j in range(m):
        c2_poly[i][j] += t_poly[j]
    ct2_poly[i] += ct_poly[i]

#decrypt(deepcopy(t2_poly), deepcopy(ct2), deepcopy(sk_s_poly))

#acc = Rq(0)
#or i in range(m):
#    acc += t2_poly[i] * sk_s_poly[i]
#mn = ct2 - acc
#mn_list = mn.list()
#m_list = []
#de_list = []
#sum_m = 0
#for i in range(d):
#    m = (round_away(float(mn_list[i]) / float(q / (2 * eval_t + 2)))) % (2 * eval_t + 2)
#    m_list.append(m)
#    de = x - m * (2 * eval_t + 2)
#    de_list.append(de)
#for i in range(32):
#    sum_m += 2**i * m_list[i]
#print(m_list)
#print(sum_m)




acc = Rq(_sage_const_0 )
for i in range(m):
    acc += c2_poly[index_s][i] * sk_s_poly[i]
mn = ct2_poly[index_s] - acc
mn_list = mn.list()
dec_m_list = []
de_list = []
sum_m = _sage_const_0 
for i in range(d):
    x = (round_away(float(mn_list[i]) / float(q / (_sage_const_2  * eval_t + _sage_const_2 )))) % (_sage_const_2  * eval_t + _sage_const_2 )
    dec_m_list.append(x)
    de = mn_list[i] - x * round_away( float (q) / float (_sage_const_2  * eval_t + _sage_const_2 ))
    cval = centered_mod(de, q) + round_away( float (q) / float (_sage_const_4  * eval_t + _sage_const_4 ))
    de_list.append(cval)
for i in range(_sage_const_32 ):
    sum_m += _sage_const_2 **i * (dec_m_list[i] - eval_t)
print("dec_m_list = ", dec_m_list)
print("rest message = ", sum_m)

bal_bin_list = int_to_bin_list(sum_m, _sage_const_64 )
print("bal_bin_list", bal_bin_list)

tmp_sum = _sage_const_0 
for i in range(_sage_const_32 ):
    tmp_sum += _sage_const_2 **i * bal_bin_list[i]
print("tmp_sum = ", tmp_sum)

bin_list, beta, length = decompose(dec_m_list[_sage_const_0 ], _sage_const_2 *eval_t + _sage_const_2  - _sage_const_1 )
mbin_list = [_sage_const_0 ] * (d * length)
for i in range(d):
    bin_list, beta, length = decompose(dec_m_list[i], _sage_const_2 *eval_t + _sage_const_2  - _sage_const_1 )
    for j in range(length):
        mbin_list[d*j + i] = bin_list[j]

print("beta = ", beta)
print("length = ", length)
#print(mbin_list)
#print(centered_mod(beta * round_away( float (q) / float (2 * eval_t + 2)), q))

delta_m_list = [_sage_const_0 ] * (d * length)
for i in range(length):
    if i < length - _sage_const_1 :
        delta_m_list[i * d] = _sage_const_2 **i * round_away( float (q) / float (_sage_const_2  * eval_t + _sage_const_2 ))
    else:
        delta_m_list[i * d] = beta * round_away( float (q) / float (_sage_const_2  * eval_t + _sage_const_2 ))
 
    
#print(de_list)

bin_list, beta2, length2 = decompose(de_list[_sage_const_0 ], round_away( float (q) / float (_sage_const_2  * eval_t + _sage_const_2 )))
debin_list = [_sage_const_0 ] * (d * length2)
for i in range(d):
    bin_list, beta2, length2 = decompose(de_list[i], round_away( float (q) / float (_sage_const_2  * eval_t + _sage_const_2 )))
    for j in range(length2):
        debin_list[d*j + i] = bin_list[j]

print("beta2 = ", beta2)
print("length2 = ", length2)
#print(debin_list)
    
#print(de_list)

shift_factor = -_sage_const_1  * round_away( float (q) / float (_sage_const_4  * eval_t + _sage_const_4 ))
#print(shift_factor)
#de_list = [x + shift_factor for x in de_list]
#print(de_list)
#back_list=[0]*d
#for i in range(d):
#    tmp = 0
#    for j in range(length2):
#        if j < length2 - 1:
#            tmp += 2**j * debin_list[j*d + i]
#        else:
#            tmp += beta2 * debin_list[j*d + i]
#    tmp += shift_factor
#    back_list[i] = tmp
#print(back_list)

# c2_poly: rec*m
# (-1) * ct2_poly: rec*1
#print("**********************")
#print(ct2_poly)
ct2_poly = [-_sage_const_1  * x for x in ct2_poly]
#print(ct2_poly)



delta_h_list = [_sage_const_0 ]*(length2 * d)
for i in range(length2):
    if i < length2 - _sage_const_1 :
        delta_h_list[i*d] = _sage_const_2 **i
    else:
        delta_h_list[i*d] = beta2

mes_factor_list = [_sage_const_0 ]*d
mes_factor_list[_sage_const_0 ] = round_away( float (q) / float (_sage_const_2  * eval_t + _sage_const_2 ))


shift_factor_list = [shift_factor]*d


bar_C_list = sum([centered_poly(p, q) for row in c2_poly for p in row], [])

minus_bar_ct_list = sum([centered_poly(ct, q) for ct in ct2_poly], [])


#print(centered_mod(shift_factor, q))


#print("old c:")
#print(t2_poly[0])
#print("old ct:")
#print(ct2)

#print("update c:")
#print(t_poly[0])
#print("update ct:")
#print(ct_poly[index_s])

#print("bar-c2-index_s:")
#print(c2_poly[index_s][0])
#print("bar-ct2-index_s:")    
#print(ct2_poly[index_s])

#exit()


    # return m_list, de_list, sum_m



#m_list, de_list, sum_m = decrypt(t2_poly, ct2, sk_s_poly, 0)
#print(sum_m)

#m_list, de_list, sum_m = decrypt(t_poly, ct_poly[index_s], sk_s_poly, 0)
#print(sum_m)

#m_list, de_list, sum_m = decrypt(c2_poly[index_s], ct2_poly[index_s], sk_s_poly, 0)
#print(sum_m)


B_T_poly = [[B_poly[i][j] for i in range(num_rec)] for j in range(n)]

tag_poly =[]
for i in range(n_pri):
    acc = Rq2(_sage_const_0 )
    for j in range(m):
        acc += AH_poly[i][j] * sh_poly[j]
    tag_poly.append(acc)

#tag_list = sum([t.list() for t in tag_poly], [])
tag_list = sum([centered_poly(t, hat_q) for t in tag_poly], [])  # 扁平连接所有多项式系数


tag_list = [floor(float(x) / _sage_const_2p0 ) for x in tag_list]

tag_p_poly = R2_to_poly_list(tag_list, n_pri, d)[:n_pri]

r_e_poly = []
for i in range(n_pri):
    acc = tag_poly[i] - _sage_const_2  * tag_p_poly[i]
    r_e_poly.append(acc)

r_e_list = sum([r_e.list() for r_e in r_e_poly], [])

#print("AH:")
#print(AH_list)
#print("sk_s:")
#print(sk_s_list)
#print("v:")
#print(tag_list)
#print("round_error:")
#print(r_e_list)
#print("inv_q:")
inv_hat_q = centered_mod(_sage_const_1 /hat_q % q, q)
#print(inv_hat_q)
#print("test")
#print(inv_hat_q * hat_q % q)

AH_list = [centered_mod( inv_hat_q * x, q) for x in AH_list]

Id_inv_list = [_sage_const_0 ] * (n_pri * n_pri * d)
for i in range(n_pri):
    for j in range(n_pri):
        if i == j:
            Id_inv_list[(i * n_pri + j) * d] = -_sage_const_1  * inv_hat_q

tag_list = [centered_mod(_sage_const_2  * inv_hat_q * x, q) for x in tag_list]

#print("***********transformed")
#print("AH:")
#print(AH_list)
#print("Id_inv:")
#print(Id_inv_list)
#print("v:")
#print(tag_list)
#print("round_error:")
#print(r_e_list)
#print("inv_q:")
#print(inv_hat_q)
# inv_hat_q = 1
# ******************* temp test
#tAH_polys = to_poly_list(AH_list, n_pri * m, d)
#tAH_poly = [[tAH_polys[i * m + j] for j in range(m)] for i in range(n_pri)]

#ttag_poly = to_poly_list(tag_list[:d * n_pri], n_pri, d)[:n_pri]

#tre_poly = to_poly_list(r_e_list[:d * n_pri], n_pri, d)[:n_pri]

#round_term = []
#for i in range(n_pri):
#    acc = Rq(0)
#    for j in range(m):
#        acc += tAH_poly[i][j] * sk_s_poly[j]
#    acc += ttag_poly[i] + tre_poly[i] * inv_hat_q
#    round_term.append(acc)

#round_term_list = sum([centered_poly(term, q) for term in round_term], [])  # 扁平连接所有多项式系数
#print("rounding term list in centered poly")
#print(round_term_list)

#exit()
# === 输出计算结果（中心模表示）===
#print("=== 计算得到的 t[i]（中心模系数） ===")
#for i, t in enumerate(t_poly):
#    print(f"t[{i}] = {centered_poly(t)}")

# === 比对 t_poly 与 temp_list（一维） ===
#print("\n=== 比对预期结果 ===")
#match = True
#for i in range(m):
#    computed = centered_poly(t_poly[i])
#    expected = temp_list[i * n:(i + 1) * n]
#    if computed != expected:
#        print(f"❌ t[{i}] 不匹配：计算值 = {computed}, 预期值 = {expected}")
#        match = False
#    else:
#        print(f"✅ t[{i}] 匹配成功")

#if match:
#    print("\n�� 所有 t[i] 与 temp_list 完全匹配！")
#else:
#    print("\n⚠️ 存在不匹配，请检查输入或计算")

# === 将 t_poly 展平成一维中心模系数数组 t_list ===
t_list = sum([centered_poly(t, q) for t in t_poly], [])  # 扁平连接所有多项式系数

ct_list = sum([centered_poly(ct, q) for ct in ct_poly], [])  # 扁平连接所有多项式系数

pk_list = sum([centered_poly(pk, q) for pk in pk_poly], [])  # 扁平连接所有多项式系数

AT_list = sum([centered_poly(p, q) for row in A_T_poly for p in row], [])

B_list = []
B_list = sum([centered_poly(p, q) for row in B_poly for p in row], [])

BT_list = sum([centered_poly(p, q) for row in B_T_poly for p in row], [])

m_list = sum([centered_poly(m, q) for m in m_poly], [])

#bin_s = [0]*num_rec
#bin_s[index_s] = 1
#bin_r = [0]*num_rec
#bin_r[index_r] = 1
bin_s_list = [_sage_const_0 ] * (d * num_rec)
bin_s_list[index_s * d] = _sage_const_1 

bin_r_list = [_sage_const_0 ] * (d * num_rec)
bin_r_list[index_r * d] = _sage_const_1 


# XXX negative BT_list for further proof
BT_list = [-x for x in BT_list]


# print(y_list)
# print(len(y_list))

# === 输出为纯一维数组（中心模系数） ===
#print("\n=== 纯一维 t_list 输出（中心模系数） ===")
#print("t_list =", t_list)

# === 提取 s_list 的前一半（对应 s 向量部分） ===
s_list_half = s_list[:len(s_list) // _sage_const_2 ]
e_list_half = s_list[len(s_list) // _sage_const_2 :]

# === 定义输出文件路径 ===
output_file = "data_temp.h"

# === 格式化为 C 数组的字符串 ===
def format_c_array(name, data):
    lines = [f"static int64_t {name}[] = {{"]
    for i in range(_sage_const_0 , len(data), _sage_const_8 ):  # 每行最多8个元素
        line = "  " + ", ".join(str(x) for x in data[i:i+_sage_const_8 ])
        if i + _sage_const_8  < len(data):
            line += ","
        lines.append(line)
    lines.append("};\n")
    return "\n".join(lines)

# === 写入文件 ===
with open(output_file, "w") as f:
    f.write("#include <stdint.h>\n\n")
    f.write(format_c_array("A_", A_list))
    f.write(format_c_array("s_", s_list_half))
    f.write(format_c_array("t_", t_list))
    f.write(format_c_array("B_", B_list))
    f.write(format_c_array("nBT_", BT_list))
    f.write(format_c_array("ct_", ct_list))
    f.write(format_c_array("e_", e_list_half))
    f.write(format_c_array("y_", y_list))
    f.write(format_c_array("mes_", m_list))
    f.write(format_c_array("IdR_", IdR_list))
    f.write(format_c_array("AT_", AT_list))
    f.write(format_c_array("pk_", pk_list))
    f.write(format_c_array("sks_", sk_s_list))
    f.write(format_c_array("ske_", sk_e_list))
    f.write(format_c_array("bin_s_", bin_s_list))
    f.write(format_c_array("bin_r_", bin_r_list))
    f.write(format_c_array("mp_", mp_list))
    f.write(format_c_array("AH_", AH_list))
    f.write(format_c_array("IdQ_", Id_inv_list))
    f.write(format_c_array("tag_", tag_list))
    f.write(format_c_array("re_", r_e_list))
    f.write(format_c_array("barC_", bar_C_list))
    f.write(format_c_array("bar_minus_ct_", minus_bar_ct_list))
    f.write(format_c_array("sf_", shift_factor_list))
    f.write(format_c_array("mf_", mes_factor_list))
    f.write(format_c_array("delta_h_", delta_h_list))
    f.write(format_c_array("dec_m_", dec_m_list))
    f.write(format_c_array("bin_h_", debin_list))
    f.write(format_c_array("bin_m_", mbin_list))
    f.write(format_c_array("delta_factor_m_", delta_m_list))
    f.write(format_c_array("bin_bal_", bal_bin_list))
    

print(f" output loaded to {output_file}")

barC_polys = to_poly_list(bar_C_list, num_rec * m, d)
barC_poly = [[barC_polys[i * m + j] for j in range(m)] for i in range(num_rec)]
barct_poly = to_poly_list(minus_bar_ct_list, num_rec, d)[:num_rec]
delat_h_poly = to_poly_list(delta_h_list, length2, d)[:length2]
delat_m_poly = to_poly_list(delta_m_list, length, d)[:length]
debin_poly = to_poly_list(debin_list, length2, d)[:length2]
mbin_poly = to_poly_list(mbin_list, length, d)[:length]
#mf_poly = Rq(mes_factor_list)
#dec_m_poly = Rq(dec_m_list)
sf_poly = Rq(shift_factor_list)


acc = Rq(_sage_const_0 )
for i in range(m):
    acc += sk_s_poly[i] * barC_poly[index_s][i]
acc += barct_poly[index_s]
for i in range(length2):
    acc += delat_h_poly[i] * debin_poly[i]
for i in range(length):
    acc += delat_m_poly[i] * mbin_poly[i]
#acc += mf_poly * dec_m_poly
acc += sf_poly

print("acc", acc)

sum = _sage_const_0 
ssum = _sage_const_0 
for i in range(length):
    sum = _sage_const_0 
    for j in range(d):
        if j < _sage_const_32 :
            sum += _sage_const_2 **j * mbin_list[i*d + j]
        else:
            break
    if i < length -_sage_const_1 :
        ssum += _sage_const_2 **i * sum
    else:
        ssum += beta * sum
ssum -= eval_t * (_sage_const_2 **_sage_const_32  - _sage_const_1 )

print("ssum = ", ssum)
print("sf in balance = ", centered_mod(eval_t * (_sage_const_2 **_sage_const_32  - _sage_const_1 ), q))
print("sf = ", eval_t * (_sage_const_2 **_sage_const_32  - _sage_const_1 ))

