

# This file was *autogenerated* from the file zeth-lin-codegen.sage
from sage.all_cmdline import *   # import sage library

_sage_const_64 = Integer(64); _sage_const_3358 = Integer(3358); _sage_const_40 = Integer(40); _sage_const_7 = Integer(7); _sage_const_2 = Integer(2); _sage_const_16 = Integer(16); _sage_const_26 = Integer(26); _sage_const_61 = Integer(61); _sage_const_59 = Integer(59); _sage_const_1 = Integer(1); _sage_const_32 = Integer(32); _sage_const_0 = Integer(0); _sage_const_20 = Integer(20); _sage_const_70368744178037 = Integer(70368744178037); _sage_const_46 = Integer(46); _sage_const_128 = Integer(128); _sage_const_15p9 = RealNumber('15.9'); _sage_const_5p3 = RealNumber('5.3'); _sage_const_6p36 = RealNumber('6.36'); _sage_const_1p6 = RealNumber('1.6'); _sage_const_3 = Integer(3); _sage_const_887 = Integer(887)
import sys

d = _sage_const_64   
PSI = _sage_const_3358  


vname = "paramsTP"
name = f"_{vname}"  

deg = _sage_const_64 

length2 = _sage_const_40 

length = _sage_const_7 

n_prime = _sage_const_2 

num_rec = _sage_const_16 

m_rows = _sage_const_26 

n_cols = _sage_const_26  

eval_t = _sage_const_61 

beta_m = _sage_const_59 
nrows = m_rows + n_cols +num_rec + n_cols + n_prime

ncols = n_cols + num_rec + m_rows + num_rec * _sage_const_2  + _sage_const_1  + n_prime + length2 + length + _sage_const_1 
 

# XXX XXX indicate regular proof, 1 for only ARP, 2 for 1 ARP and 1 bin/exact norm proof
num_norm = _sage_const_2 

# indicate additional ARP
add_ARP = _sage_const_1 

# indicate integer proof
bit_proof = _sage_const_2 
bit_index = n_cols + num_rec + m_rows
bit_length = num_rec * _sage_const_2 

mes_index = n_cols
mp_index = n_cols + num_rec + m_rows + num_rec * _sage_const_2 

bin_h_index = n_cols + num_rec + m_rows + num_rec * _sage_const_2  + _sage_const_1  + n_prime 
bin_m_index = n_cols + num_rec + m_rows + num_rec * _sage_const_2  + _sage_const_1  + n_prime + length2
bin_bal_index = n_cols + num_rec + m_rows + num_rec * _sage_const_2  + _sage_const_1  + n_prime + length2 + length
balance_range = _sage_const_32 

nbin = m_rows + num_rec * _sage_const_2  + _sage_const_1  + n_prime + length2 + length


wdim = ncols   # dimension of witness vector

# XXX 
wpart = [list(range(_sage_const_0 , n_cols + num_rec)), list(range(n_cols + num_rec, wdim))]

wnsub = len(wpart)      

wl2 = [_sage_const_0 , _sage_const_0 ]
wbin = [_sage_const_0 , _sage_const_1 ]


wlinf = _sage_const_20 


mod = _sage_const_70368744178037 

k = deg/d
P = ( mod -_sage_const_1 )/_sage_const_2 
S = wlinf  # bound on linf(s)
E = _sage_const_0    # bound on linf(e), n/a here


log2q = _sage_const_46 
lambda2 = ceil(_sage_const_128 /log2q)

# find dimension of binary vector
nbin_ = _sage_const_0 
for i in range(wnsub):
    if wbin[i] == _sage_const_1 :
        nbin_ += len(wpart[i])
nbin = k * nbin_       # set length of vector with binary coefficients

# find dimensions of vectors bounded in l2 norm
n_ = []
B_ = []
for i in range(wnsub):
    if wl2[i] > _sage_const_0 :
        n_ += [len(wpart[i])]
        B_ += [wl2[i]]
n = [i * k for i in n_]
B = B_.copy()
n = []
B = []

# find dimension of vector bounded in linf norm
nprime = k * nrows
Bprime = _sage_const_15p9 *_sage_const_5p3      # set linf norm bound


# copy l2 bound list and insert naive l2 norm bounds for binary vectors
wl2_ = wl2.copy()
for i in range(wnsub):
    if wl2_[i] == _sage_const_0 :
        wl2_[i] = sqrt((_sage_const_1  ** _sage_const_2 ) * deg * len(wpart[i]))

# XXX
wl2_ = [_sage_const_0 , sqrt(deg * nbin)]


# Search for smallest proof size:
# 1. Put the whole witness in the Ajtai part.
# 2. Find the subvector v of largest l2-norm in the Ajtai part and move v to the BDLOP part.
# 3. If the proof size decreased, go back to 2. Otherwise, move v back to the Ajtai part and stop.
ajtai = [i for i in range(wnsub)]  # list of subvectors in Ajtai part
bdlop = []  # list of subvectors in BDLOP part

#***** give below value
m1 = wdim     # set length of vector s1 (committed in Ajtai part)
l = _sage_const_0          # set length of vector m (committed in BDLOP part)
# set l2-norm bound on vector s1

#***** give this alpha value
alpha = ceil(sqrt( n_cols * d * (_sage_const_6p36 *_sage_const_1p6 )**_sage_const_2 ) +  (m_rows + _sage_const_3  + length + length2 + _sage_const_1 ) * d + _sage_const_2 )


##########################
## compute parameters
##########################

verbose = _sage_const_1 
code = _sage_const_1 
loaded = _sage_const_1 
codegen_err = _sage_const_0 
load("zeth-lnp-tbox-codegen.sage")




##########################
## output parameters 
##########################

# indices of elements of w that go to s1
s1_indices = []
Ps_indices = []
Es_indices = []
for i in ajtai:
    if wbin[i] == _sage_const_1 :
        Ps_indices += list(range(len(s1_indices),
                                 len(s1_indices)+len(wpart[i])))
    if wl2[i] > _sage_const_0 :
        Es_indices += [list(range(len(s1_indices),
                                  len(s1_indices)+len(wpart[i])))]
    s1_indices += wpart[i]
# indices of elements of w that go to m
m_indices = []
Em_indices = []
for i in bdlop:
    # cant put binary subvecs in ajtai (Pm not implemented)
    assert wbin[i] == _sage_const_0 
    if wl2[i] > _sage_const_0 :
        Em_indices += [list(range(len(s1_indices),
                                  len(s1_indices)+len(wpart[i])))]
    m_indices += wpart[i]


out = ""

if Ps_indices == []:
    matPs_nrows = _sage_const_0 
    vname_Ps = f"NULL"
else:
    out += f"static const unsigned int {vname}_Ps[{len(Ps_indices)}] = {intlist2intarray(Ps_indices)};\n"
    matPs_nrows = len(Ps_indices)
    vname_Ps = f"{vname}_Ps"

vname_Es = []
for i in range(len(Es_indices)):
    _Es_indices = Es_indices[i]
    if _Es_indices == []:
        vname_Es += [f"NULL"]
    else:
        out += f"static const unsigned int {vname}_Es{i}[{len(_Es_indices)}] = {intlist2intarray(_Es_indices)};\n"
        vname_Es += [f"{vname}_Es{i}"]
if Es_indices == []:
    strEs = "NULL"
    strEs_nrows = "NULL"
else:
    strEs = f"{vname}_Es"
    strEs_nrows = f"{vname}_Es_nrows"
    out += f"static const unsigned int *{vname}_Es[{len(Es_indices)}] = {{ "
    for i in range(len(Es_indices)):
        out += f"{vname_Es[i]}, "
    out += f"}};\n"
    out += f"static const unsigned int {vname}_Es_nrows[{len(Es_indices)}] = {intlist2intarray([len(i) for i in Es_indices])};\n"

vname_Em = []
for i in range(len(Em_indices)):
    _Em_indices = Em_indices[i]
    if _Em_indices == _sage_const_0 :
        vname_Em += [f"NULL"]
    else:
        out += f"static const unsigned int {vname}_Em{i}[{len(_Em_indices)}] = {intlist2intarray(_Em_indices)};\n"
        vname_Em += [f"{vname}_Em{i}"]
if Em_indices == []:
    strEm = "NULL"
    strEm_nrows = "NULL"
else:
    strEm = f"{vname}_Es"
    strEm_nrows = f"{vname}_Es_nrows"
    out += f"static const unsigned int *{vname}_Em[{len(Em_indices)}] = {{ "
    for i in range(len(Em_indices)):
        out += f"{vname_Em[i]}, "
    out += f"}};\n"
    out += f"static const unsigned int {vname}_Em_nrows[{len(Em_indices)}] = {intlist2intarray([len(i) for i in Em_indices])};\n"

if l > _sage_const_0 :
    out += f"static const unsigned int {vname}_m_indices[{len(m_indices)}] = {intlist2intarray(m_indices)};\n"
    vname_m_indices = f"{vname}_m_indices"
else:
    vname_m_indices = f"NULL"

mod = _sage_const_887 *_sage_const_2 
# note: here to avoid output error in pinv, we temporarily set mod = 70368744176221 which is different with read q
out += f"""
{int_t(f"{vname}_p", mod)}
{int_t(f"{vname}_pinv", redc(_sage_const_1 /mod % q, q))}
static const unsigned int {vname}_s1_indices[{len(s1_indices)}] = {intlist2intarray(s1_indices)};
static const lin_params_t {vname} = {{
{{ {name}, {deg}, {vname}_p, {vname}_pinv, {k}, 
{vname}_s1_indices, {len(s1_indices)},
{vname_m_indices}, {len(m_indices)}, 
{vname_Ps}, {matPs_nrows}, 
{strEs}, {strEs_nrows}, 
{strEm}, {strEm_nrows} }}
}};
"""
printc(out)

##########################
## output parameters finished
##########################

